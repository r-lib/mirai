---
output: hugodown::hugo_document
slug: mirai-2-6-0
title: mirai 2.6.0
date: 2026-02-10
author: Charlie Gao
description: >
    mirai 2.6.0 brings an HTTP launcher for cloud and Posit Workbench,
    a C-level dispatcher for double-digit microsecond round-trips, and
    new tools for racing and debugging async tasks.
photo:
  url: https://unsplash.com/photos/nighttime-traffic-light-trails-captured-with-long-exposure-6-QINjM3DSM
  author: Egor Litvinov
categories: [package]
tags: [mirai, parallelism, r-lib]
---

```{r}
#| include: false
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```

We're fired up to announce the release of [mirai](https://mirai.r-lib.org) 2.6.0.
mirai is R's minimalist async evaluation framework -- it lets you send work to background processes and get results back, whether those processes are on your laptop or across a cluster.

You can install it from CRAN with:

```r
install.packages("mirai")
```

This release introduces the HTTP launcher for deploying daemons via any HTTP API (with Posit Workbench defaults built in), a dispatcher that's been re-implemented entirely in C for dramatically lower overhead, and a reworked `race_mirai()` for efficient process-as-completed patterns.
You can see a full list of changes in the [release notes](https://mirai.r-lib.org/news/).

```{r}
#| include: false
library(mirai)
```

## HTTP launcher

The headline feature of this release is `http_config()`, a new remote launch configuration that deploys daemons via HTTP API calls.

If you're new to mirai, the idea is simple: you write code with `mirai()`, and background processes called *daemons* do the actual work.
The question is just how those daemons get started.
On your laptop, `daemons(4)` spins up four local processes and you're done.
For remote machines, mirai already offered SSH, HPC cluster managers (Slurm, SGE, PBS, LSF), and generic shell commands.
The HTTP launcher adds a fourth option: any platform with an HTTP API for launching jobs.

### Posit Workbench

Many organizations running research and data science at scale use [Posit Workbench](https://posit.co/products/enterprise/workbench/) to manage their compute.
mirai now integrates directly with it.
Call `http_config()` with no arguments and it auto-configures using the Workbench environment:

```r
daemons(n = 4, url = host_url(), remote = http_config())
```

That's it.
Four daemons launch as Workbench jobs, connect back to your session, and you can start sending work to them.

Under the hood, `http_config()` stores *functions* rather than static values for credentials and endpoint URLs.
These functions are only called at the moment daemons actually launch, so session cookies and API tokens are always fresh -- even if you created the configuration earlier in your session.

### Custom APIs

The HTTP launcher works with any HTTP API, not just Workbench.
Supply your own endpoint, authentication, and request body:

```r
daemons(
  n = 2,
  url = host_url(),
  remote = http_config(
    url = "https://api.example.com/launch",
    method = "POST",
    token = function() Sys.getenv("MY_API_KEY"),
    data = '{"command": "%s"}'
  )
)
```

The `"%s"` placeholder in `data` is where mirai inserts the daemon launch command at launch time.
Each argument can be a plain value or a function -- use functions for anything that changes between launches (tokens, cookies, dynamic URLs).

## C-level dispatcher

The dispatcher is the process that sits between your host session and the daemons, routing tasks in FIFO order.
In this release, the dispatcher loop has been re-implemented entirely in C code within [nanonext](https://nanonext.r-lib.org), cutting overhead roughly in half.

What does that mean in practice?
Round-trip response times for task dispatch are now in the double-digit microsecond range.
The dispatcher was already event-driven and non-polling (consuming zero CPU when idle), but moving the hot path to C shaves off the R interpreter overhead that remained.
For workflows that fire off many small tasks -- think `mirai_map()` over thousands of items -- this is a noticeable improvement.

## `race_mirai()`

`race_mirai()` was introduced in mirai 2.5.1 for waiting on the first of several mirai to complete.
This release refines it: `race_mirai()` now returns the integer *index* of the first resolved mirai, rather than the entire list.

This makes the "process as completed" pattern clean and efficient:

```r
daemons(4)

tasks <- lapply(1:10, function(i) mirai({Sys.sleep(runif(1)); i}))

remaining <- tasks
while (length(remaining) > 0) {
  idx <- race_mirai(remaining)
  cat("Completed:", remaining[[idx]]$data, "\n")
  remaining <- remaining[-idx]
}

daemons(0)
```

Send off a batch of tasks, then process results in the order they finish -- no polling, no wasted time waiting on the slowest one.
If any mirai is already resolved when you call `race_mirai()`, it returns immediately.

## Synchronous mode

Also introduced in 2.5.1: `daemons(sync = TRUE)` runs everything synchronously in the current process.
No background processes, no networking -- just sequential execution.

Why would you want that?
Debugging.
When something goes wrong inside a mirai, it can be hard to step through because the code runs in a separate process.
Synchronous mode lets you use `browser()` and other interactive debugging tools directly:

```r
daemons(sync = TRUE)
mirai({
  browser()
  some_complex_function(x)
}, x = my_data)
```

You can scope it to a specific compute profile if you only want certain tasks to run synchronously while others continue in parallel.

## Minor improvements and fixes

- `everywhere()` gains a `.min` argument for specifying the minimum number of daemons on which to evaluate (when using dispatcher). This creates a synchronization point -- useful when launching remote daemons that take time to connect.
- `miraiError` objects now have proper `conditionCall()` and `conditionMessage()` methods, making them work correctly with R's standard condition handling.
- The default `autoexit = TRUE` behaviour has been updated for OpenTelemetry compatibility, with a 200ms grace period before forceful termination.
- OpenTelemetry span names and attributes have been upgraded to better follow semantic conventions.
- `mirai_map()` now returns invisibly, consistent with `mirai()`.
- `daemons()` now properly validates that `url` is a character value, rather than silently falling back to local daemons.
- Fixed a bug where repeated mirai cancellation could sometimes cause a daemon to exit prematurely.

## Growing adoption

It's been great to see mirai adopted by an expanding range of projects.
Recently, [ragnar](https://github.com/tidyverse/ragnar) -- the Tidyverse package for retrieval-augmented generation (RAG) -- chose mirai for its async backend.
Seeing mirai power AI workflows alongside traditional data science pipelines is a testament to the framework's versatility.

As an [official alternative communications backend](https://stat.ethz.ch/R-manual/R-devel/library/parallel/html/makeCluster.html) for R's parallel package, mirai continues to be a foundation that the broader R ecosystem can build on.
There's more to come from Posit's investment in this space -- stay tuned.

## Acknowledgements

A big thank you to all the folks who helped make this release happen:

[@agilly](https://github.com/agilly), [@aimundo](https://github.com/aimundo), [@barnabasharris](https://github.com/barnabasharris), [@beevabeeva](https://github.com/beevabeeva), [@boshek](https://github.com/boshek), [@eliocamp](https://github.com/eliocamp), [@jan-swissre](https://github.com/jan-swissre), [@jeroenjanssens](https://github.com/jeroenjanssens), [@kentqin-cve](https://github.com/kentqin-cve), [@mcol](https://github.com/mcol), [@michaelmayer2](https://github.com/michaelmayer2), [@pmac0451](https://github.com/pmac0451), [@r2evans](https://github.com/r2evans), [@shikokuchuo](https://github.com/shikokuchuo), [@t-kalinowski](https://github.com/t-kalinowski), [@VincentGuyader](https://github.com/VincentGuyader), [@wlandau](https://github.com/wlandau), and [@xwanner](https://github.com/xwanner).
